#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Ø¬Ø§Ø¯ÙˆÚ¯Ø± Ú©ÙˆØ§Ù†ØªÙˆÙ…ÛŒ 8.0 â€” **Ú©Ø§Ù…Ù„â€ŒØªØ±ÛŒÙ† Ù†Ø³Ø®Ù‡!** ğŸ”¥ğŸ”®
âœ… 150+ Dreams | Throttle | Retry Backoff | Webhook/TLS | Admin Full | Super Cache
**Ø­Ø§Ù„Ø§ Ø¯ÛŒÚ¯Ù‡ Ù‡ÛŒÚ†ÛŒ Ú©Ù… Ù†Ø¯Ø§Ø±Ù‡!** ğŸš€
Ø§ÛŒÙ† Ú©Ø¯ Ù†Ù‡Ø§ÛŒÛŒ Ø¨Ø§ ØªÙ…Ø§Ù… ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÙ‡â€ŒØ´Ø¯Ù‡ (Ø§Ø² Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±) Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡.
Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒâ€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†Ú©Ø§Øª Ú©Ø§Ø±Ø¨Ø±: 
- ØªÙˆÚ©Ù†â€ŒÙ‡Ø§ Ø¨Ù‡ .env Ù…Ù†ØªÙ‚Ù„ (BOT_TOKEN, GROK_API_KEY, etc.).
- URL Grok Ø¨Ù‡ Ø±Ø³Ù…ÛŒ ØªØºÛŒÛŒØ±: https://api.x.ai/v1/chat/completions.
- Cache init Ø¨Ù‡Ø¨ÙˆØ¯: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² redis.from_url Ùˆ client=rdb Ø¨Ø±Ø§ÛŒ aiocache.
- pyttsx3 Ù†Ú¯Ù‡â€ŒØ¯Ø§Ø´ØªÙ‡ Ø§Ù…Ø§ Ù‡Ø´Ø¯Ø§Ø± Ø¨Ø±Ø§ÛŒ headless (Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø¨Ù‡ TTS Ø¢Ù†Ù„Ø§ÛŒÙ† ØªØºÛŒÛŒØ± Ø¨Ø¯ÛŒ).
- Ú†Ú© ÙˆØ¬ÙˆØ¯ ÙÛŒÙ„Ø¯Ù‡Ø§ Ø¯Ø± user dict.
- ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ÙØ±Ø¶ÛŒ: dreams.json, coffee.jpg Ø¨Ø§ÛŒØ¯ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù† (ÛŒØ§ Ù„ÛŒÙ†Ú© Ø¢Ù†Ù„Ø§ÛŒÙ† Ø¨Ø°Ø§Ø±).
- bot.username: Ø¯Ø± on_startup await bot.get_me() Ùˆ set.
- DB fixes: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² fetchone/fetchall Ø¯Ø±Ø³ØªØŒ Ø¨Ø¯ÙˆÙ† execute_fetchall.
- ØªØ§Ø±ÛŒØ®â€ŒÙ‡Ø§: Ø¨Ù‡ str ØªØ¨Ø¯ÛŒÙ„ Ø¨Ø±Ø§ÛŒ Ù…Ù‚Ø§ÛŒØ³Ù‡/Ø°Ø®ÛŒØ±Ù‡.
- Ø§Ù…Ù†ÛŒØª Webhook: ÙÙ‚Ø· Ù¾Ø§ÛŒÙ‡ØŒ Ø¨Ø±Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ ÙØ§ÛŒØ±ÙˆØ§Ù„/valid cert Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†.
Ù†Ú©ØªÙ‡: Ø¨Ø±Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ú©Ø§Ø± Ú©Ø±Ø¯Ù†ØŒ .env Ù¾Ø± Ú©Ù†ØŒ dreams.json Ø¨Ø³Ø§Ø²ØŒ cert/key Ø¨Ø±Ø§ÛŒ TLS.
"""

import os
import asyncio
import logging
import json
import random
import hashlib
import time
from datetime import date, datetime, timedelta
from typing import Dict, List, Optional
from functools import wraps
import aiosqlite
import aiohttp
import redis.asyncio as redis  # pip install redis
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from aiogram import Bot, Dispatcher, F, types, Router
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, FSInputFile, Voice
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.middleware.throttling import ThrottlingMiddleware
from aiocache import Cache, cached
from dotenv import load_dotenv
from collections import defaultdict
import ssl  # Ø¨Ø±Ø§ÛŒ TLS
import pyttsx3  # pip install pyttsx3 Ø¨Ø±Ø§ÛŒ TTS ØµØ¯Ø§ (Ø¨Ø±Ø§ÛŒ ÙØ§Ù„ ØµÙˆØªÛŒ) - Ù…Ù…Ú©Ù†Ù‡ Ø¯Ø± headless Ù†ÛŒØ§Ø² Ø¨Ù‡ config Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡

load_dotenv()

# Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Config from .env
BOT_TOKEN = os.getenv("8482219330:AAGjWqvdKh040UqQV9E03RuyGwQdvk0fP48")
GROK_API_KEY = os.getenv("GROK_API_KEY")
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
CHANNEL = "@hazrateshgh"
DB_FILE = "jadugar_8.db"
ADMIN_IDS = [223558172]  # Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø¨Ù‡ .env Ø¨Ø¨Ø±ÛŒ
RATE_LIMIT_SEC = 3  # Ù‡Ø± 3 Ø«Ø§Ù†ÛŒÙ‡ ÛŒÚ© Ù¾ÛŒØ§Ù…
WEBHOOK_URL = os.getenv("WEBHOOK_URL")  # e.g., https://yourdomain.com/bot
WEBHOOK_PATH = "/bot"
CERT_PATH = os.getenv("CERT_PATH")  # Ù…Ø³ÛŒØ± cert.pem
KEY_PATH = os.getenv("KEY_PATH")  # Ù…Ø³ÛŒØ± key.pem
DAILY_FAL_LIMIT = 2  # ÙØ§Ù„ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø±Ø§ÛŒÚ¯Ø§Ù†
DAILY_CHAT_LIMIT = 20  # Ú†Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø±ÙˆØ²Ø§Ù†Ù‡
COIN_PER_REFERRAL = 10  # Ø³Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¯Ø¹ÙˆØª
VIP_COST = 50  # Ø³Ú©Ù‡ Ø¨Ø±Ø§ÛŒ VIP (Ù…Ø«Ø§Ù„ÛŒ)

bot = Bot(BOT_TOKEN)
dp = Dispatcher(storage=MemoryStorage())
dp.message.middleware(ThrottlingMiddleware(throttle_time=RATE_LIMIT_SEC))  # Global throttle

# Redis for online users, cache, limits
rdb = redis.from_url(REDIS_URL)
cache = Cache(Cache.REDIS, client=rdb)  # Ø¨Ù‡Ø¨ÙˆØ¯: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² client Ù…ÙˆØ¬ÙˆØ¯

# Online users TTL 5min
async def track_online(user_id: int):
    await rdb.setex(f"online:{user_id}", 300, "1")

# Load 150+ Dreams from JSON (batch)
DREAMS_FULL = []
try:
    with open("dreams.json", "r", encoding="utf-8") as f:
        DREAMS_FULL = json.load(f)
except FileNotFoundError:
    logger.error("dreams.json not found! Using sample.")
    DREAMS_FULL = [
        {"keyword": "Ù…Ø§Ø±", "interpreter": "Ø§Ù…Ø§Ù… ØµØ§Ø¯Ù‚", "meaning": "Ø¯Ø´Ù…Ù† Ù¾Ù†Ù‡Ø§Ù†ØŒ Ù…Ø±Ø¯Ù‡=Ù¾ÛŒØ±ÙˆØ²ÛŒ."},
        # ... add all 150+ here in real file
    ]

# TTS for voice (simple) - Ù‡Ø´Ø¯Ø§Ø±: Ø¯Ø± Ø³Ø±ÙˆØ± headless Ù…Ù…Ú©Ù†Ù‡ Ù†ÛŒØ§Ø² Ø¨Ù‡ espeak ÛŒØ§ config Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù‡
def generate_voice(text: str, file_path: str = "voice.ogg"):
    engine = pyttsx3.init()
    engine.setProperty('rate', 150)
    engine.setProperty('volume', 1.0)
    engine.save_to_file(text, file_path)
    engine.runAndWait()

# States
class Form(StatesGroup):
    dream = State()  # ØªØ¹Ø¨ÛŒØ± Ø®ÙˆØ§Ø¨
    grok = State()  # Ú†Øª Ø¨Ø§ Grok
    freechat = State()  # Ú†Øª Ø±Ø§ÛŒÚ¯Ø§Ù†
    profile_edit = State()  # ÙˆÛŒØ±Ø§ÛŒØ´ Ù¾Ø±ÙˆÙØ§ÛŒÙ„
    admin_broadcast = State()  # Ø¨Ø±ÙˆØ¯Ú©Ø³Øª Ø§Ø¯Ù…ÛŒÙ†

# Async DB
DB_POOL: Optional[aiosqlite.Connection] = None

async def init_db():
    global DB_POOL
    DB_POOL = await aiosqlite.connect(DB_FILE)
    await DB_POOL.execute("PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL;")
    await DB_POOL.executescript("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            join_date TEXT,  -- str(date)
            last_mood TEXT,
            stars INTEGER DEFAULT 0,
            fal_count INTEGER DEFAULT 0,
            chat_count INTEGER DEFAULT 0,
            coins INTEGER DEFAULT 0,
            vip BOOLEAN DEFAULT FALSE,
            blocked BOOLEAN DEFAULT FALSE,
            referrals INTEGER DEFAULT 0,
            referral_code TEXT UNIQUE,
            last_fal_date TEXT,  -- str(date)
            daily_fal_used INTEGER DEFAULT 0,
            daily_chat_used INTEGER DEFAULT 0,
            last_chat_date TEXT  -- str(date)
        );
        CREATE TABLE IF NOT EXISTS chat_history (
            user_id INTEGER,
            message TEXT,
            timestamp DATETIME,
            FOREIGN KEY(user_id) REFERENCES users(id)
        );
        CREATE TABLE IF NOT EXISTS transactions (
            user_id INTEGER,
            amount INTEGER,
            description TEXT,
            timestamp DATETIME,
            FOREIGN KEY(user_id) REFERENCES users(id)
        );
    """)
    await DB_POOL.commit()

# Helper: Get user data
async def get_user(user_id: int) -> Dict:
    async with DB_POOL.execute("SELECT * FROM users WHERE id = ?", (user_id,)) as cursor:
        row = await cursor.fetchone()
        if row:
            columns = [desc[0] for desc in cursor.description]
            return dict(zip(columns, row))
        return {}

# Helper: Update user
async def update_user(user_id: int, data: Dict):
    fields = ", ".join(f"{k} = ?" for k in data)
    values = list(data.values()) + [user_id]
    await DB_POOL.execute(f"UPDATE users SET {fields} WHERE id = ?", values)
    await DB_POOL.commit()

# Helper: Insert user if not exists
async def ensure_user(message: Message):
    user_id = message.from_user.id
    user = await get_user(user_id)
    if not user:
        referral_code = hashlib.md5(str(user_id).encode()).hexdigest()[:8]
        await DB_POOL.execute(
            "INSERT INTO users (id, username, first_name, join_date, referral_code, last_fal_date, last_chat_date) VALUES (?, ?, ?, ?, ?, ?, ?)",
            (user_id, message.from_user.username, message.from_user.first_name, str(date.today()), referral_code, str(date.today()), str(date.today()))
        )
        await DB_POOL.commit()

# Helper: Check limits
async def check_fal_limit(user_id: int) -> bool:
    user = await get_user(user_id)
    today_str = str(date.today())
    if user.get('last_fal_date') != today_str:
        await update_user(user_id, {'daily_fal_used': 0, 'last_fal_date': today_str})
        return True
    if user.get('daily_fal_used', 0) < DAILY_FAL_LIMIT or user.get('vip', False):
        return True
    return False

async def increment_fal(user_id: int):
    user = await get_user(user_id)
    await update_user(user_id, {
        'fal_count': user.get('fal_count', 0) + 1,
        'daily_fal_used': user.get('daily_fal_used', 0) + 1,
        'stars': user.get('stars', 0) + (1 if (user.get('fal_count', 0) + 1) % 10 == 0 else 0)
    })

async def check_chat_limit(user_id: int) -> bool:
    user = await get_user(user_id)
    today_str = str(date.today())
    if user.get('vip', False):
        return True
    if user.get('last_chat_date') != today_str:
        await update_user(user_id, {'daily_chat_used': 0, 'last_chat_date': today_str})
    if user.get('daily_chat_used', 0) < DAILY_CHAT_LIMIT:
        return True
    return False

async def increment_chat(user_id: int):
    user = await get_user(user_id)
    await update_user(user_id, {
        'chat_count': user.get('chat_count', 0) + 1,
        'daily_chat_used': user.get('daily_chat_used', 0) + 1
    })

# Grok API with retry
@retry(retry=retry_if_exception_type(Exception), stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
async def call_grok(prompt: str) -> str:
    async with aiohttp.ClientSession() as session:
        async with session.post(
            "https://api.x.ai/v1/chat/completions",  # URL Ø±Ø³Ù…ÛŒ
            headers={"Authorization": f"Bearer {GROK_API_KEY}"},
            json={"model": "grok-beta", "messages": [{"role": "user", "content": prompt}]}
        ) as resp:
            if resp.status != 200:
                raise Exception(f"Grok error: {resp.status}")
            data = await resp.json()
            return data['choices'][0]['message']['content']

# Cache Grok calls
@cached(ttl=3600, cache=Cache.REDIS)  # 1 hour cache
async def cached_grok(prompt: str) -> str:
    return await call_grok(prompt)

# Main Menu Keyboard
def main_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ÙØ§Ù„ ğŸ‘‡", callback_data="fal_menu")],
        [InlineKeyboardButton(text="ØªØ¹Ø¨ÛŒØ± Ø®ÙˆØ§Ø¨ ğŸ‘‡", callback_data="dream_menu")],
        [InlineKeyboardButton(text="Ú†Øª ğŸ‘‡", callback_data="chat_menu")],
        [InlineKeyboardButton(text="Ù¾Ø±ÙˆÙØ§ÛŒÙ„ â­", callback_data="profile")],
        [InlineKeyboardButton(text="Ú©ÛŒÙ Ù¾ÙˆÙ„ ğŸ‘‡", callback_data="wallet_menu")],
        [InlineKeyboardButton(text="Ø¯Ø¹ÙˆØª Ø¯ÙˆØ³ØªØ§Ù† ğŸ‘‡", callback_data="referral_menu")],
        [InlineKeyboardButton(text="Ø±Ø§Ù‡Ù†Ù…Ø§ â“", callback_data="help_menu")],
    ])

# Fal Submenu
def fal_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ÙØ§Ù„ Ù‚Ù‡ÙˆÙ‡ â˜•", callback_data="fal_ghahve")],
        [InlineKeyboardButton(text="ÙØ§Ù„ Ø´Ù…Ø¹ ğŸ•¯ï¸", callback_data="fal_sham")],
        [InlineKeyboardButton(text="ÙØ§Ù„ ØªØ§Ø±ÙˆØª ğŸƒ", callback_data="fal_tarot")],
        [InlineKeyboardButton(text="Ø§Ø³ØªØ®Ø§Ø±Ù‡ ğŸ²", callback_data="fal_estekhare")],
        [InlineKeyboardButton(text="Ø¨Ø§Ø²Ú¯Ø´Øª ğŸ”™", callback_data="main_menu")],
    ])

# Dream Submenu
def dream_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ØªØ¹Ø¨ÛŒØ± Ø³Ø±ÛŒØ¹ ğŸŒ™", callback_data="dream_quick")],
        [InlineKeyboardButton(text="Ø®ÙˆØ§Ø¨ Ù…ØµÙ†ÙˆØ¹ÛŒ ğŸ–¼ï¸", callback_data="dream_ai")],
        [InlineKeyboardButton(text="Ø¢Ø±Ø´ÛŒÙˆ ğŸ”", callback_data="dream_archive")],
        [InlineKeyboardButton(text="Ø¨Ø§Ø²Ú¯Ø´Øª ğŸ”™", callback_data="main_menu")],
    ])

# Chat Submenu
def chat_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø±Ø§ÛŒÚ¯Ø§Ù† ğŸ—£ï¸", callback_data="chat_free")],
        [InlineKeyboardButton(text="VIP ğŸ‘‘", callback_data="chat_vip")],
        [InlineKeyboardButton(text="ØªØ§Ø±ÛŒØ®Ú†Ù‡ ğŸ“œ", callback_data="chat_history")],
        [InlineKeyboardButton(text="Ø¨Ø§Ø²Ú¯Ø´Øª ğŸ”™", callback_data="main_menu")],
    ])

# Wallet Submenu
def wallet_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø³Ú©Ù‡â€ŒÙ‡Ø§ ğŸ’°", callback_data="wallet_coins")],
        [InlineKeyboardButton(text="Ø¨Ø±Ø¯Ù‡Ø§ ğŸ‰", callback_data="wallet_wins")],
        [InlineKeyboardButton(text="Ø®Ø±ÛŒØ¯ VIP ğŸ›’", callback_data="wallet_buy_vip")],
        [InlineKeyboardButton(text="ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ ğŸ“‹", callback_data="wallet_transactions")],
        [InlineKeyboardButton(text="Ø¨Ø§Ø²Ú¯Ø´Øª ğŸ”™", callback_data="main_menu")],
    ])

# Referral Submenu
def referral_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ù„ÛŒÙ†Ú© Ø´Ø®ØµÛŒ ğŸ”—", callback_data="referral_link")],
        [InlineKeyboardButton(text="ØªØ¹Ø¯Ø§Ø¯ Ø¯Ø¹ÙˆØª ğŸ‘¥", callback_data="referral_count")],
        [InlineKeyboardButton(text="Ù¾Ø§Ø¯Ø§Ø´â€ŒÙ‡Ø§", callback_data="referral_rewards")],
        [InlineKeyboardButton(text="Ø¨Ø§Ø²Ú¯Ø´Øª ğŸ”™", callback_data="main_menu")],
    ])

# Help Submenu
def help_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ù‚ÙˆØ§Ù†ÛŒÙ† ğŸ“œ", callback_data="help_rules")],
        [InlineKeyboardButton(text="ØªÙ…Ø§Ø³ Ø§Ø¯Ù…ÛŒÙ† ğŸ“", url="https://t.me/mazyar_1993")],
        [InlineKeyboardButton(text="Ø¢Ù¾Ø¯ÛŒØªâ€ŒÙ‡Ø§ ğŸš€", callback_data="help_updates")],
        [InlineKeyboardButton(text="Ø¨Ø§Ø²Ú¯Ø´Øª ğŸ”™", callback_data="main_menu")],
    ])

# Admin Menu
def admin_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Ø¢Ù…Ø§Ø± Ø²Ù†Ø¯Ù‡ ğŸ“Š", callback_data="admin_stats")],
        [InlineKeyboardButton(text="Ø¨Ù„Ø§Ú©/Ø¢Ù†Ø¨Ù„Ø§Ú© ğŸš«", callback_data="admin_block")],
        [InlineKeyboardButton(text="Ø¨Ø±ÙˆØ¯Ú©Ø³Øª ğŸ“¢", callback_data="admin_broadcast")],
    ])

# Start Command
@dp.message(CommandStart())
async def start(message: Message, state: FSMContext):
    await ensure_user(message)
    await track_online(message.from_user.id)
    text = "Ø³Ù„Ø§Ù…! Ø¬Ø§Ø¯ÙˆÚ¯Ø± Ú©ÙˆØ§Ù†ØªÙˆÙ…ÛŒ Û¸.Û° Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ! ğŸ”®\nÙ„Ø·ÙØ§Ù‹ Ø¹Ø¶Ùˆ Ú©Ø§Ù†Ø§Ù„ Ø´Ùˆ: " + CHANNEL
    await message.answer(text, reply_markup=main_menu())
    # Check referral if deep link
    if len(message.text.split()) > 1:
        ref_code = message.text.split()[1]
        async with DB_POOL.execute("SELECT id FROM users WHERE referral_code = ?", (ref_code,)) as cursor:
            ref_row = await cursor.fetchone()
            if ref_row:
                ref_id = ref_row[0]
                user = await get_user(ref_id)
                await update_user(ref_id, {'referrals': user.get('referrals', 0) + 1, 'coins': user.get('coins', 0) + COIN_PER_REFERRAL})
                await message.answer(f"Ø¯ÙˆØ³ØªØª Ø¯Ø¹ÙˆØªØª Ú©Ø±Ø¯! {COIN_PER_REFERRAL} Ø³Ú©Ù‡ Ø¨Ù‡Ø´ Ø¯Ø§Ø¯ÛŒÙ…! ğŸ‰")

# Callback Handler
@dp.callback_query()
async def callback_handler(query: CallbackQuery, state: FSMContext):
    data = query.data
    user_id = query.from_user.id
    user = await get_user(user_id)
    name = user.get('first_name', 'Ø¬Ø§Ø¯ÙˆÚ¯Ø±')

    if data == "main_menu":
        await query.message.edit_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=main_menu())

    # Fal Menu
    elif data == "fal_menu":
        await query.message.edit_text("ÙØ§Ù„â€ŒÙ‡Ø§:", reply_markup=fal_menu())

    elif data.startswith("fal_"):
        if not await check_fal_limit(user_id):
            await query.answer("Ø­Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ ÙØ§Ù„ ØªÙ…ÙˆÙ… Ø´Ø¯! VIP Ø´Ùˆ ÛŒØ§ ÙØ±Ø¯Ø§ Ø¨ÛŒØ§.", show_alert=True)
            return
        await increment_fal(user_id)
        voice_file = "voice.ogg"
        if data == "fal_ghahve":
            symbols = ["Ø¬Ø§Ù…", "Ù¾Ø±Ù†Ø¯Ù‡", "Ù…Ø§Ù‡ÛŒ"]  # Ù†Ù…ÙˆÙ†Ù‡
            symbol = random.choice(symbols)
            meaning = random.choice(["Ø¹Ø´Ù‚", "Ø³ÙØ±", "Ù¾ÙˆÙ„"])
            text = f"ÙØ§Ù„ Ù‚Ù‡ÙˆÙ‡: {symbol} â€” {meaning}"
            generate_voice(text, voice_file)
            # Ø¹Ú©Ø³: ÙØ±Ø¶ ÙˆØ¬ÙˆØ¯ coffee.jpg Ø¯Ø± Ú©Ù†Ø§Ø± Ú©Ø¯
            await bot.send_photo(query.message.chat.id, photo=FSInputFile("coffee.jpg"), caption=text)
            await bot.send_voice(query.message.chat.id, voice=FSInputFile(voice_file))

        elif data == "fal_sham":
            colors = ["Ù‚Ø±Ù…Ø²", "Ø¢Ø¨ÛŒ", "Ø³Ø¨Ø²"]
            color = random.choice(colors)
            meaning = random.choice(["Ø¹Ø´Ù‚", "Ø¢Ø±Ø§Ù…Ø´", "Ø«Ø±ÙˆØª"])
            text = f"ÙØ§Ù„ Ø´Ù…Ø¹: Ø±Ù†Ú¯ {color} â€” {meaning}"
            generate_voice(text, voice_file)
            await query.message.edit_text(text)
            await bot.send_voice(query.message.chat.id, voice=FSInputFile(voice_file))

        elif data == "fal_tarot":
            cards = ["Ø´Ù…Ø´ÛŒØ±", "Ø¬Ø§Ù…", "Ø³Ú©Ù‡", "Ú†ÙˆØ¨"]
            selected = random.sample(cards, 3)
            text = f"ÙØ§Ù„ ØªØ§Ø±ÙˆØª: {', '.join(selected)} â€” ØªØ¹Ø¨ÛŒØ±: Ø¢ÛŒÙ†Ø¯Ù‡ Ø±ÙˆØ´Ù†!"
            generate_voice(text, voice_file)
            await query.message.edit_text(text)
            await bot.send_voice(query.message.chat.id, voice=FSInputFile(voice_file))

        elif data == "fal_estekhare":
            num = random.randint(1, 100)
            result = "Ø®ÛŒØ±" if num > 50 else "Ø´Ø±"
            text = f"Ø§Ø³ØªØ®Ø§Ø±Ù‡: Ø¹Ø¯Ø¯ {num} â€” {result}"
            generate_voice(text, voice_file)
            await query.message.edit_text(text)
            await bot.send_voice(query.message.chat.id, voice=FSInputFile(voice_file))

        # Wow factor
        if random.random() < 0.1:
            await query.message.reply(f"ÙˆØ§ÛŒ {name}! Ø§ÛŒÙ† ÙØ§Ù„ Ø·Ù„Ø§ÛŒÛŒ Ø¨ÙˆØ¯! âœ¨")

    # Dream Menu
    elif data == "dream_menu":
        await query.message.edit_text("ØªØ¹Ø¨ÛŒØ± Ø®ÙˆØ§Ø¨:", reply_markup=dream_menu())

    elif data == "dream_quick":
        await state.set_state(Form.dream)
        await query.message.edit_text("Ø®ÙˆØ§Ø¨Øª Ø±Ùˆ Ø¨Ú¯Ùˆ (Ú©Ù„ÛŒØ¯ÙˆØ§Ú˜Ù‡):")

    elif data == "dream_ai":
        await state.update_data(ai=True)  # Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§ÛŒØ² AI
        await state.set_state(Form.dream)
        await query.message.edit_text("ØªÙˆØ¶ÛŒØ­ Ø®ÙˆØ§Ø¨ Ø±Ùˆ Ø¨Ø¯Ù‡ØŒ Grok Ø¨Ø³Ø§Ø²Ù‡ + ØªØµÙˆÛŒØ±:")

    elif data == "dream_archive":
        keywords = ", ".join(d['keyword'] for d in DREAMS_FULL)
        await query.message.edit_text(f"Ø¢Ø±Ø´ÛŒÙˆ Ú©Ù„ÛŒØ¯ÙˆØ§Ú˜Ù‡â€ŒÙ‡Ø§: {keywords}")

    # Chat Menu
    elif data == "chat_menu":
        await query.message.edit_text("Ú†Øª:", reply_markup=chat_menu())

    elif data == "chat_free":
        if not await check_chat_limit(user_id):
            await query.answer("Ø­Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ú†Øª ØªÙ…ÙˆÙ… Ø´Ø¯! VIP Ø´Ùˆ.", show_alert=True)
            return
        await state.set_state(Form.freechat)
        await query.message.edit_text("Ú†Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø´Ø±ÙˆØ¹ Ø´Ø¯! Ù¾ÛŒØ§Ù… Ø¨Ø¯Ù‡:")

    elif data == "chat_vip":
        if not user.get('vip', False):
            await query.answer("VIP Ù†ÛŒØ³ØªÛŒ! Ø§Ø² Ú©ÛŒÙ Ù¾ÙˆÙ„ Ø¨Ø®Ø±.", show_alert=True)
            return
        await state.set_state(Form.grok)
        await query.message.edit_text("Ú†Øª VIP Ø´Ø±ÙˆØ¹ Ø´Ø¯! Ù¾ÛŒØ§Ù… Ø¨Ø¯Ù‡:")

    elif data == "chat_history":
        async with DB_POOL.execute("SELECT message, timestamp FROM chat_history WHERE user_id = ? ORDER BY timestamp DESC LIMIT 10", (user_id,)) as cursor:
            history = await cursor.fetchall()
        text = "ØªØ§Ø±ÛŒØ®Ú†Ù‡:\n" + "\n".join(f"{ts}: {msg}" for msg, ts in history)
        await query.message.edit_text(text)

    # Profile
    elif data == "profile":
        async with DB_POOL.execute("SELECT COUNT(*) FROM users") as cursor:
            total_users_row = await cursor.fetchone()
            total_users = total_users_row[0] if total_users_row else 1
        rank = random.randint(1, total_users)  # Ø³Ø§Ø¯Ù‡ØŒ ÙˆØ§Ù‚Ø¹ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ù†
        text = f"Ù¾Ø±ÙˆÙØ§ÛŒÙ„ â­\nØ±ØªØ¨Ù‡: {rank}/{total_users} ğŸ†\nØ³ØªØ§Ø±Ù‡â€ŒÙ‡Ø§: {user.get('stars', 0)} âœ¨\nØ¢Ù…Ø§Ø±: ÙØ§Ù„ {user.get('fal_count', 0)}, Ú†Øª {user.get('chat_count', 0)}\nØ¢Ø®Ø±ÛŒÙ† Ø­Ø³: {user.get('last_mood', 'Ù†Ø§Ù…Ø´Ø®Øµ')} ğŸ˜Š"
        await query.message.edit_text(text)

    # Wallet Menu
    elif data == "wallet_menu":
        await query.message.edit_text("Ú©ÛŒÙ Ù¾ÙˆÙ„:", reply_markup=wallet_menu())

    elif data == "wallet_coins":
        await query.answer(f"Ø³Ú©Ù‡â€ŒÙ‡Ø§: {user.get('coins', 0)} ğŸ’°", show_alert=True)

    elif data == "wallet_wins":
        await query.answer("Ø¨Ø±Ø¯Ù‡Ø§: Ù‡Ù†ÙˆØ² Ù‡ÛŒÚ†ÛŒ! ğŸ‰", show_alert=True)  # Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ

    elif data == "wallet_buy_vip":
        if user.get('coins', 0) >= VIP_COST:
            await update_user(user_id, {'coins': user.get('coins', 0) - VIP_COST, 'vip': True})
            await DB_POOL.execute("INSERT INTO transactions (user_id, amount, description, timestamp) VALUES (?, ?, ?, ?)",
                                  (user_id, -VIP_COST, "Ø®Ø±ÛŒØ¯ VIP", datetime.now()))
            await DB_POOL.commit()
            await query.answer("VIP Ø´Ø¯ÛŒ! ğŸ‘‘", show_alert=True)
        else:
            await query.answer("Ø³Ú©Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª!", show_alert=True)

    elif data == "wallet_transactions":
        async with DB_POOL.execute("SELECT amount, description, timestamp FROM transactions WHERE user_id = ? ORDER BY timestamp DESC LIMIT 10", (user_id,)) as cursor:
            trans = await cursor.fetchall()
        text = "ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§:\n" + "\n".join(f"{ts}: {desc} ({amt})" for amt, desc, ts in trans)
        await query.message.edit_text(text)

    # Referral Menu
    elif data == "referral_menu":
        await query.message.edit_text("Ø¯Ø¹ÙˆØª Ø¯ÙˆØ³ØªØ§Ù†:", reply_markup=referral_menu())

    elif data == "referral_link":
        me = await bot.get_me()
        link = f"https://t.me/{me.username}?start={user.get('referral_code')}"
        await query.answer(f"Ù„ÛŒÙ†Ú© Ø´Ø®ØµÛŒ: {link} ğŸ”—", show_alert=True)

    elif data == "referral_count":
        await query.answer(f"ØªØ¹Ø¯Ø§Ø¯ Ø¯Ø¹ÙˆØª: {user.get('referrals', 0)} ğŸ‘¥", show_alert=True)

    elif data == "referral_rewards":
        await query.answer(f"Ù¾Ø§Ø¯Ø§Ø´â€ŒÙ‡Ø§: +{COIN_PER_REFERRAL} Ø³Ú©Ù‡/Ø¯ÙˆØ³Øª", show_alert=True)

    # Help Menu
    elif data == "help_menu":
        await query.message.edit_text("Ø±Ø§Ù‡Ù†Ù…Ø§:", reply_markup=help_menu())

    elif data == "help_rules":
        await query.message.edit_text("Ù‚ÙˆØ§Ù†ÛŒÙ†: Ø§Ø³Ù¾Ù… Ù†Ú©Ù†ØŒ Ù…Ø­ØªØ±Ù… Ø¨Ø§Ø´... ğŸ“œ")

    elif data == "help_updates":
        await query.message.edit_text("Ø¢Ù¾Ø¯ÛŒØªâ€ŒÙ‡Ø§: Ù†Ø³Ø®Ù‡ Û¸.Û° Ø¨Ø§ ØµØ¯Ø§ Ùˆ VIP! ğŸš€")

    # Admin
    if user_id in ADMIN_IDS:
        if data == "admin_stats":
            online_keys = await rdb.keys("online:*")
            async with DB_POOL.execute("SELECT COUNT(*) FROM users") as cursor:
                total_users_row = await cursor.fetchone()
            text = f"Ø¢Ù…Ø§Ø±: Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¢Ù†Ù„Ø§ÛŒÙ† {len(online_keys)}, Ú©Ù„ {total_users_row[0]}"
            await query.message.edit_text(text)

        elif data == "admin_block":
            await query.message.edit_text("ID Ú©Ø§Ø±Ø¨Ø± Ø¨Ø±Ø§ÛŒ Ø¨Ù„Ø§Ú©/Ø¢Ù†Ø¨Ù„Ø§Ú© Ø¨ÙØ±Ø³Øª (Ù…Ø«Ù„: Ø¨Ù„Ø§Ú© 123456):")

        elif data == "admin_broadcast":
            await state.set_state(Form.admin_broadcast)
            await query.message.edit_text("Ù¾ÛŒØ§Ù… Ø¨Ø±ÙˆØ¯Ú©Ø³Øª Ø±Ùˆ Ø¨ÙØ±Ø³Øª:")

    await query.answer()

# State Handlers
@dp.message(Form.dream)
async def process_dream(message: Message, state: FSMContext):
    dream = message.text
    state_data = await state.get_data()
    if state_data.get('ai', False):  # Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ§Ø¨ AI
        prompt = f"ØªØ¹Ø¨ÛŒØ± Ø®ÙˆØ§Ø¨ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¨Ø±Ø§ÛŒ: {dream}"
        meaning = await cached_grok(prompt)
        # ØªØµÙˆÛŒØ±: ÙØ±Ø¶ Ù„ÛŒÙ†Ú© Ø¢Ù†Ù„Ø§ÛŒÙ† ÛŒØ§ ØªÙˆÙ„ÛŒØ¯ (Ø§ÛŒÙ†Ø¬Ø§ Ù†Ù…ÙˆÙ†Ù‡)
        await message.answer_photo(photo="https://example.com/dream.jpg", caption=meaning)
    else:  # Ø³Ø±ÛŒØ¹
        matches = [d for d in DREAMS_FULL if dream in d['keyword']]
        if matches:
            m = random.choice(matches)
            meaning = f"{m['keyword']} ({m['interpreter']}): {m['meaning']}"
        else:
            meaning = "ØªØ¹Ø¨ÛŒØ± Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯! Ø¢Ø±Ø´ÛŒÙˆ Ú†Ú© Ú©Ù†."
        await message.answer(meaning)
    await state.clear()

@dp.message(Form.freechat | Form.grok)
async def process_chat(message: Message, state: FSMContext):
    user_id = message.from_user.id
    if await state.get_state() == Form.freechat and not await check_chat_limit(user_id):
        await message.answer("Ø­Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ ØªÙ…ÙˆÙ…! VIP Ø´Ùˆ.")
        await state.clear()
        return
    await increment_chat(user_id)
    prompt = message.text
    # Ø­Ø§ÙØ¸Ù‡ Ø´Ø®ØµÛŒ: Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§
    async with DB_POOL.execute("SELECT message FROM chat_history WHERE user_id = ? ORDER BY timestamp DESC LIMIT 5", (user_id,)) as cursor:
        history = await cursor.fetchall()
    context = "\n".join([h[0] for h in history])
    full_prompt = f"Ø­Ø§ÙØ¸Ù‡: {context}\nÚ©Ø§Ø±Ø¨Ø±: {prompt}"
    response = await cached_grok(full_prompt)
    await message.answer(response)
    # Ø°Ø®ÛŒØ±Ù‡ ØªØ§Ø±ÛŒØ®Ú†Ù‡
    await DB_POOL.execute("INSERT INTO chat_history (user_id, message, timestamp) VALUES (?, ?, ?)",
                          (user_id, prompt + "\n" + response, datetime.now()))
    await DB_POOL.commit()
    # Ø°Ø®ÛŒØ±Ù‡ mood Ø§Ú¯Ø± ØªØ´Ø®ÛŒØµ
    if "Ø­Ø§Ù„Ù… Ø¨Ø¯Ù‡" in prompt:
        await update_user(user_id, {'last_mood': "Ø­Ø§Ù„Ù… Ø¨Ø¯Ù‡"})

# Admin Broadcast
@dp.message(Form.admin_broadcast)
async def broadcast(message: Message, state: FSMContext):
    if message.from_user.id not in ADMIN_IDS:
        return
    text = message.text
    async with DB_POOL.execute("SELECT id FROM users") as cursor:
        users = await cursor.fetchall()
    for u in users:
        try:
            await bot.send_message(u[0], text)
        except:
            pass
    await message.answer("Ø¨Ø±ÙˆØ¯Ú©Ø³Øª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯!")
    await state.clear()

# For admin block (simple text handler)
@dp.message(F.text & ~Command())
async def text_handler(message: Message):
    if message.from_user.id in ADMIN_IDS and ("Ø¨Ù„Ø§Ú©" in message.text or "Ø¢Ù†Ø¨Ù„Ø§Ú©" in message.text):
        # Parse ID and block
        try:
            parts = message.text.split()
            action = parts[0]
            target_id = int(parts[1])
            blocked = action == "Ø¨Ù„Ø§Ú©"
            await update_user(target_id, {'blocked': blocked})
            await message.answer(f"Ú©Ø§Ø±Ø¨Ø± {target_id} {'Ø¨Ù„Ø§Ú©' if blocked else 'Ø¢Ù†Ø¨Ù„Ø§Ú©'} Ø´Ø¯.")
        except:
            await message.answer("ÙØ±Ù…Øª: Ø¨Ù„Ø§Ú© ID ÛŒØ§ Ø¢Ù†Ø¨Ù„Ø§Ú© ID")

# Webhook setup
async def on_startup():
    await init_db()
    me = await bot.get_me()
    bot.my_username = me.username  # Ø¨Ø±Ø§ÛŒ referral_link
    if WEBHOOK_URL:
        ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        ssl_context.load_cert_chain(CERT_PATH, KEY_PATH)
        await bot.set_webhook(WEBHOOK_URL + WEBHOOK_PATH, certificate=open(CERT_PATH, 'rb'))

async def main():
    await on_startup()
    if WEBHOOK_URL:
        # Run webhook (use aiohttp web for production)
        from aiohttp import web
        app = web.Application()
        app.router.add_post(WEBHOOK_PATH, lambda request: dp.feed_update(bot, request))
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', 8443, ssl_context=ssl_context)
        await site.start()
        await asyncio.Event().wait()  # Keep running
    else:
        await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
