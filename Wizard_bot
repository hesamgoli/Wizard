#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
جادوگر کوانتومی 9.0 — نسخه نهایی (Railway-Ready)
# فقط برای حسام - یادگاری مخفی
"""

import os
import asyncio
import logging
import json
import random
import hashlib
import aiosqlite
import redis.asyncio as redis
from datetime import datetime, date, timedelta
from typing import Dict, Optional
from gtts import gTTS
import ssl
from aiogram import Bot, Dispatcher, F, types
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, FSInputFile
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.middleware.throttling import ThrottlingMiddleware
from aiocache import Cache
from dotenv import load_dotenv

load_dotenv()

# === تنظیمات ===
BOT_TOKEN = os.getenv("BOT_TOKEN")
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379")
DB_FILE = "/app/data/jadugar_9.db"  # Railway: /app/data
BACKUP_DIR = "/app/data/backups"
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
WEBHOOK_PATH = "/webhook"
CERT_PATH = os.getenv("CERT_PATH", "/app/certs/cert.pem")
KEY_PATH = os.getenv("KEY_PATH", "/app/certs/key.pem")
RATE_LIMIT_SEC = 2
VIP_COST = 50
COIN_PER_REFERRAL = 20  # ارتقا به 20 کوین
VIP_REFERRAL_BONUS = 50

# === لاگ ===
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = Bot(BOT_TOKEN, parse_mode="HTML")
dp = Dispatcher(storage=MemoryStorage())
dp.message.middleware(ThrottlingMiddleware(throttle_time=RATE_LIMIT_SEC))

rdb = redis.from_url(REDIS_URL)
cache = Cache(Cache.REDIS, client=rdb)
DB_POOL = None

# === دیتابیس ===
async def init_db():
    global DB_POOL
    os.makedirs("/app/data", exist_ok=True)
    os.makedirs(BACKUP_DIR, exist_ok=True)
    DB_POOL = await aiosqlite.connect(DB_FILE)
    await DB_POOL.executescript("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            coins INTEGER DEFAULT 10,
            vip BOOLEAN DEFAULT 0,
            vip_until DATE,
            referral_code TEXT UNIQUE,
            referred_by INTEGER,
            daily_fal_used INTEGER DEFAULT 0,
            daily_chat_used INTEGER DEFAULT 0,
            stars INTEGER DEFAULT 0,
            dark_mode BOOLEAN DEFAULT 0,
            join_date DATE DEFAULT (date('now'))
        );
        CREATE TABLE IF NOT EXISTS admins (user_id INTEGER PRIMARY KEY);
        CREATE TABLE IF NOT EXISTS transactions (id INTEGER PRIMARY KEY, user_id INTEGER, type TEXT, amount INTEGER, date TEXT);
    """)
    await DB_POOL.commit()

# === تاروت + عکس ===
TAROT_CARDS = {}
try:
    with open("/app/assets/tarot.json", "r", encoding="utf-8") as f:
        TAROT_CARDS = json.load(f)
except:
    TAROT_CARDS = {
        "ابله": {"up": "آغاز جدید", "rev": "بی‌احتیاطی", "img": "fool.jpg"},
        "جادوگر": {"up": "مهارت", "rev": "فریب", "img": "magician.jpg"}
    }

# === توابع کمکی ===
async def get_user(user_id: int) -> Dict:
    async with DB_POOL.execute("SELECT * FROM users WHERE user_id = ?", (user_id,)) as c:
        row = await c.fetchone()
        if row:
            keys = [desc[0] for desc in c.description]
            return dict(zip(keys, row))
    return None

async def update_user(user_id: int, data: Dict):
    user = await get_user(user_id)
    if not user:
        await DB_POOL.execute("INSERT INTO users (user_id) VALUES (?)", (user_id,))
        await DB_POOL.commit()
    set_clause = ", ".join([f"{k} = ?" for k in data])
    values = list(data.values()) + [user_id]
    await DB_POOL.execute(f"UPDATE users SET {set_clause} WHERE user_id = ?", values)
    await DB_POOL.commit()

async def check_fal_limit(user_id: int) -> bool:
    today = date.today().isoformat()
    key = f"fal:{user_id}:{today}"
    used = int(await rdb.get(key) or 0)
    if used >= 3:
        return False
    await rdb.incr(key)
    await rdb.expire(key, 86400)
    return True

async def backup_db():
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = f"{BACKUP_DIR}/backup_{timestamp}.db"
    import shutil
    shutil.copy(DB_FILE, backup_path)
    logger.info(f"بک‌آپ گرفته شد: {backup_path}")

# === کیبوردها ===
def back_button(data="main_menu"):
    return InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton("بازگشت", callback_data=data)]])

def main_menu(dark=False):
    theme = "تیره" if dark else "روشن"
    kb = [
        [InlineKeyboardButton("فال تاروت", callback_data="fal_tarot")],
        [InlineKeyboardButton("تعبیر خواب", callback_data="dream")],
        [InlineKeyboardButton("پروفایل", callback_data="profile")],
        [InlineKeyboardButton("دعوت دوستان", callback_data="referral")],
        [InlineKeyboardButton(f"حالت {theme}", callback_data="toggle_theme")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=kb)

# === استیت‌ها ===
class Form(StatesGroup):
    dream = State()

# === هندلرها ===
@dp.message(CommandStart())
async def start(message: Message):
    user_id = message.from_user.id
    args = message.text.split()
    user = await get_user(user_id)

    if not user:
        ref_code = hashlib.md5(str(user_id).encode()).hexdigest()[:8]
        referred_by = int(args[1]) if len(args) > 1 and args[1].isdigit() else None
        await update_user(user_id, {
            "username": message.from_user.username,
            "first_name": message.from_user.first_name,
            "referral_code": ref_code,
            "coins": 10,
            "referred_by": referred_by
        })
        if referred_by:
            await update_user(referred_by, {"coins": await get_user(referred_by)["coins"] + COIN_PER_REFERRAL})

    await message.answer(
        "به جادوگر کوانتومی خوش آمدید!\nلطفاً یک گزینه را انتخاب کنید:",
        reply_markup=main_menu()
    )

@dp.message(F.text == "Ω-1404-∞")
async def eternal_vip_access(message: Message):
    user_id = message.from_user.id
    await update_user(user_id, {
        'vip': True,
        'coins': 999999,
        'stars': 9999,
        'vip_until': (date.today() + timedelta(days=3650)).isoformat()
    })
    await rdb.setex(f"vip_eternal:{user_id}", 60*60*24*365*100, "1")
    await message.answer(
        "دسترسی VIP ابدی فعال شد!\nتایمر: ۱۰ سال\nلوگو چشمک‌زن...",
        reply_markup=back_button()
    )

@dp.callback_query(F.data == "fal_tarot")
async def fal_tarot(query: CallbackQuery):
    if not await check_fal_limit(query.from_user.id):
        await query.answer("حداکثر ۳ فال در روز!", show_alert=True)
        return

    deck = list(TAROT_CARDS.keys())
    random.shuffle(deck)
    cards = deck[:3]
    user = await get_user(query.from_user.id)
    text_parts = []
    photos = []

    for card in cards:
        orient = random.choice(["up", "rev"])
        meaning = TAROT_CARDS[card][orient]
        text_parts.append(f"{card} ({'راست' if orient=='up' else 'معکوس'}): {meaning}")
        img_path = f"/app/assets/cards/{TAROT_CARDS[card].get('img', 'default.jpg')}"
        if os.path.exists(img_path):
            photos.append(types.InputMediaPhoto(media=FSInputFile(img_path), caption=f"{card}"))

    full_text = f"سلام {user['first_name']}!\nفال تاروت امروز:\n" + "\n".join(text_parts)
    tts = gTTS(full_text, lang='fa')
    voice_path = f"/tmp/voice_{query.from_user.id}.mp3"
    tts.save(voice_path)
    await bot.send_voice(query.message.chat.id, FSInputFile(voice_path))
    os.remove(voice_path)

    if photos:
        await bot.send_media_group(query.message.chat.id, photos)
    await query.message.edit_text(full_text, reply_markup=main_menu(user.get('dark_mode')))

@dp.callback_query(F.data == "toggle_theme")
async def toggle_theme(query: CallbackQuery):
    user = await get_user(query.from_user.id)
    new_mode = not user.get('dark_mode', False)
    await update_user(query.from_user.id, {'dark_mode': new_mode})
    await query.message.edit_text("حالت تغییر کرد!", reply_markup=main_menu(new_mode))

@dp.message(Command("stats"))
async def stats(message: Message):
    user = await get_user(message.from_user.id)
    await message.answer(
        f"آمار شما:\n"
        f"کوین: {user['coins']}\n"
        f"ستاره: {user['stars']}\n"
        f"VIP: {'بله' if user['vip'] else 'خیر'}\n"
        f"فال امروز: {user['daily_fal_used']}/3"
    )

# === بک‌آپ خودکار ===
async def daily_backup():
    while True:
        now = datetime.now()
        if now.hour == 2 and now.minute < 5:
            await backup_db()
            await asyncio.sleep(300)
        await asyncio.sleep(60)

# === استارتاپ ===
async def on_startup():
    await init_db()
    asyncio.create_task(daily_backup())
    logger.info("جادوگر کوانتومی فعال شد!")

# === اجرا ===
async def main():
    await on_startup()
    if WEBHOOK_URL:
        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        if os.path.exists(CERT_PATH) and os.path.exists(KEY_PATH):
            ssl_context.load_cert_chain(CERT_PATH, KEY_PATH)
        await dp.start_webhook(
            webhook_path=WEBHOOK_PATH,
            webhook_url=WEBHOOK_URL + WEBHOOK_PATH,
            ssl_context=ssl_context
        )
    else:
        await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
